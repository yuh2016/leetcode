#算法

##排序

###算法2.1 选择排序 Selection
>选择最小的元素与第一个元素交换。然后在剩下的元素中选择最小的元素与第二元素交换。。。
#####时间复杂度
- 交换次数：N
- 比较次数：(N-1) + (N-2) + ... + 1 = N(N-1)/2 ~ N^2


###算法2.2 插入排序 Insertion
>每个元素与之前的依次比较，小的话交换

####时间复杂度
- 交换次数 最小N次，最大 
- 比较次数 最小N次，最大 

####特点
 - 适合适当有序，小规模的数组

###算法2.3 希尔排序 Shell
基于插入排序（插入排序对于小规模、有序的数组很有用）
>使数组中任意间隔为h的数组都是有序的<br>
>最终对于h=1，对数组进行插入排序<br>
>如果h很大，可以使较大的元素直接移动到右侧<br>

###归并算法Merge
####原地归并的抽象方法
>把2个有序数组归并到一个数组里<br>
>将数组复制到新的数组,再归并到原数组

####算法2.4 自顶向下的归并排序
>基于原地归并的抽象方法实现的一种递归归并的算法。

用不同的方法处理小规模问题能改进大多数递归算法的性能， 因为递归会使小规模问题中方法的调用过于频繁， 所以改进对它们的处理方法就能改进整个算法。
例如:插入排序在小数组上比归并排序更快。

####自底向上的归并排序 MergeBU

#####分治思想
>将一个大问题分割成小问题分别解决，然后用所有小问题的答案解决整个大问题。

###算法2.5 快速排序 Quick
是一种实现分治的算法。将一个数组分为2部分，对这2部分分别排序。
>优点：<br>
>1,原地排序（只需要很小的一个辅助栈） <br>
>2,将长度为N的数组排序的时间和NlgN成正比 <br>
>3,快速排序的内循环比大多数排序都要短小 <br>
>缺点：<br>
>实现时需要很小心才能避免低劣的性能









